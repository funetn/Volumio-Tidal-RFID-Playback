import socketio
import csv
import evdev  # For reading RFID as input events
from time import sleep

# CSV Record Layout
# rfidtag,tidal://album/13346481,Artist-Album Name (artist field can have spaces)
# or
# rfidtag,tidal:album:13346481,Artist_album Name (artist field can have spaces)


# Config
CSV_FILE = 'rfid_lookup.csv'  # Your lookup file
RFID_DEVICE_PATH = '/dev/input/event0'  # Replace with your actual device path from the test above
VOLUMIO_HOST = 'http://localhost:3000'  # Or remote IP: 'http://192.168.1.230:3000'

# Load CSV into dict: tag -> {'uri': ..., 'artist': ...}
def load_lookup(csv_file):
    lookup = {}
    with open(csv_file, 'r') as f:
        reader = csv.DictReader(f)
        for row in reader:
            tag = row['tag'].strip()
            lookup[tag] = {'uri': row['uri'].strip(), 'artist': row['artist'].strip()}
    print(f"Loaded {len(lookup)} entries from {csv_file}")
    return lookup

# Socket.io setup
sio = socketio.Client(reconnection=True, reconnection_attempts=10, reconnection_delay=1)

@sio.event
def connect():
    print("Connected to Volumio!")

@sio.event
def disconnect():
    print("Disconnected from Volumio")

@sio.on('pushState')
def on_state(data):
    print("Playback state:", data.get('status'), data.get('title'))

@sio.on('pushQueue')
def on_queue(data):
    print(f"Queue updated: {len(data)} items")

def play_tidal_album(album_uri, album_title="", album_art=""):
    if not sio.connected:
        print("Not connected to Volumio!")
        return

    item = {
        "uri": album_uri,
        "service": "tidal",
        "title": album_title,
        "albumart": album_art  # Optional
    }

    print(f"Playing: {album_title or album_uri}")
    sio.emit("replaceAndPlay", item)  # Clear queue, add album, play

# Main
try:
    sio.connect(VOLUMIO_HOST)
    sleep(2)  # Wait for connection
except Exception as e:
    print("Connection failed:", e)
    exit(1)

lookup = load_lookup(CSV_FILE)

# RFID reading with evdev
device = evdev.InputDevice(RFID_DEVICE_PATH)
print(f"Listening for RFID scans on {device.name} ({device.path})...")

key_map = {  # Map evdev key codes to digits/symbols (standard for numeric tags)
    evdev.ecodes.KEY_0: '0', evdev.ecodes.KEY_1: '1', evdev.ecodes.KEY_2: '2',
    evdev.ecodes.KEY_3: '3', evdev.ecodes.KEY_4: '4', evdev.ecodes.KEY_5: '5',
    evdev.ecodes.KEY_6: '6', evdev.ecodes.KEY_7: '7', evdev.ecodes.KEY_8: '8',
    evdev.ecodes.KEY_9: '9',
    # Add more if your tags have letters/symbols (e.g., KEY_A: 'A')
}

tag_buffer = []
for event in device.read_loop():
    if event.type == evdev.ecodes.EV_KEY and event.value == 1:  # Key down
        if event.code in key_map:
            tag_buffer.append(key_map[event.code])
        elif event.code == evdev.ecodes.KEY_ENTER:
            tag = ''.join(tag_buffer).strip()
            if tag:
                print(f"Scanned tag: {tag}")
                entry = lookup.get(tag)
                if entry:
                    play_tidal_album(entry['uri'], entry['artist'])
                else:
                    print(f"Tag {tag} not found in CSV")
                tag_buffer = []  # Reset for next scan
